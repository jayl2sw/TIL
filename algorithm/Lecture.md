# 알고리즘



### 정렬

* 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
* 아래의 예는 6개의 변수를 사용





### 정렬

* 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값, 혹은 그 반대의 순서대로 재배열하는 것
* `key`: 자료를 정렬하는 기준이 되는 특정 값

* 버블 정렬(Bubble Sort) O(n^2)
  * 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
  * 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
  * 한단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
  * 교환하며 자리를 이동하는 모습이 물위에 올라오는 거품 모양과 같아고 하여 버블 정렬이라고 한다.



* 카운팅 정렬(Counting Sort) O(N)



### 순열(Permutation)

* 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
* 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다. `nPr`
* 그리고 nPr은 다음과 같은 식이 성립한다. `nPr` = `n!/(n-r)!`
* `nPn` = n! Factorial



포함하는 모든 순열을 생성하는 함수 

```python
for i1 in range(1, 4):
    for i 2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3!=i1 and i3 != i2:
                    print(i1, i2, i3)
```



### 그리디(탐욕) 알고리즘

* 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법

* 여러 경우 중 하나를 결정해야 할 때 마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.

* 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.

* 일반적으로, 머릿속에 떠오르는 생각을 검증없이 구현하면 Greedy접근이 된다.

  

ex) 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?

1. 해선택: 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어든다.
2. 실행 가능성 검사: 액수를 초과 하는 지 확인한다. 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고 1)로 돌아가서 한단계 작은 단위의 동전을 추가하낟.
3. 해 검사 : 일치하면 멈춘다. 



### 탐욕알고리즘 Baby-gin 풀이

* 6개의 숫자는 6자리의 정수 값으로 입력된다.
* counts 배열의 각 원소를 체크하여 run과 triplet 및 baby-gin 여부를 확인한다.



### 검색

* 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
* 목적하는 탐색키를 가진 항목을 찾는 것
  * 탐색키 : 자료를 구별하여 인식 할 수 있는 키
* 검색의 종류
  * 순차 검색(Sequential search)
  * 이진 검색(Binary Search)
  * 해쉬 (Hash)

### 순차 검색 (Sequential Search)

* 일렬로 되어 있는 자료를 순서대로 검색하는 방법

  * 가장 간단하고 직관적인 검색방법
  * 알고리즘 단순하여 구현 쉽지만 검색 대상의 수가 많은 경우에 수행시간이 급격히 증가

* 2가지 경우

  * 정렬되어 있지 않은 경우
  * 정렬되어 있는 경우

* 검색 과정

  * 첫번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.

  * 키값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다.

  * 자료 끝까지 못찾으면 검색 실패

    

* 구현 예 ==> 인덱스부터 검사해야 한다. 그렇지 않으면 내용을 확인하다가 인덱스 에러 발생 가능

* 정렬이 되어 있지 않을 때, 

  * 찾고자 하는 원소의 순서에 따라 비교 회수가 결정됨
  * 시간 복잡도: O(n)

* 정렬이 되어 있는 경우

  * 자료를 순차적으로 검색하면서 키값을 비교하여 원소의 키값이 검색대상의 키 값보다 크면 찾는 원소가 없다는 뜻  => 더이상 검색 x

  * 시간 복잡도: O(n)